document.getElementById("body").innerHTML = "<pre><code>" + `
-----------------------------------------------------------------------------------------

// 1. DOM behind scenes

DOM - interface between javascript and the browser. JS creates, modififies etc. html documents that are rendered in and by the browser. 
DOM tree is generated from an Html document, which we can then interact with.

DOM api is broken into different types of nodes, which are represented by JS objects:

<img src="http://127.0.0.1:5500/Udemy%20course/img/AdvancedDOM_node_types.JPG" height="80%" width="80%"/>


// 2. Elements manipulation


Selecting:

document.querySelector('.header'); // returns first element that matches,  . - selector 

document.querySelectorAll('.section'); // all elements

document.getElementById('section--1');

document.getElementsByTagName('button'); // returns all elements' html collection (live collection). If DOM changes then collection is updated automatically

document.getElementsByClassName('btn'); // as above


Creating:

//document.insertAdjacentHTML();

const message = document.createElement('div'); // creates DOM element
message.classList.add('cookie-message');
messaage.textContent = '21:37' ;
message.innerHTML = '<button class='btn'></button>';

const header = document.querySelector('.header');
header.prepend(message); // adds element inside header before first element
header.append(message); // adds element inside header after..

first prepend will be canceled by append
header.append(message.cloneNode(true)); // this will clone node and allow to add message before and after header

header.before(message); // adds element as header's sibling before header
header.after(message); // adds element as header's sibling after header


Deleting:

document.querySelector('btn--close--cokie').addEventListener('click', function() {
    message.remove();
    //also possible
    message.parentElement.removeChild(message); // 'DOM traversing'
});


// 3. Styles, attributes, classes

Styles:
// this works for things we define ourselves, it wont work to already applied style from CSS
message.style.background = '#37383d';
message.style.width = '120%';

getComputedSyle(element); // returns CSS declaration with a lot of style properties

document.documentElement.style.setProperty('--color-primary', 'orangered');

Attributes:

<div class="nav__logo" src="img/logo.png height="100%" ... />

const logo = document.querySelector('.nav__logo');
logo.src // img/logo.png          ===========>      logo.getAttribute('src')
logo src = 'bla' ===> logo.setAttribute('src', 'bla')

direct property => full path
getAttribute func => relative path

Classes:

logo.classList.add('c', 'j');
logo.classList.remove('c', 'j');
logo.classList.toggle('c');
logo.classList.contains('c'); // not includes like in arrays

! dont use will overwrite class list? - logo.className = 'test';

// 4. Events and event handlers

event - signal generated by a DOM node (click, hoover, key pressed, window closed etc.)
event handler - listens for specified type of signal and reacts with implemented logic

Example event types:
click, mouseenter (like hoover), mouseleave, select, 


OLD SCHOOL:
h1.onmouseenter(function(e){
    console.log('test');
});

NEW SCHOOL:
h1.addEventListener('mouseenter', function(e) {
    console.log('test');
});

Event listener can be romeved for example it could be placed in addEventListener so the event would be handled only once
h1.removeEventListener('mousenter', function(e) {
    console.log('test');
})

Bubbling and capturing - event propagation:

Element (e.g button) is nested in DOM nodes - document -> html -> body -> section -> p -> el. Event is generated at the root of element - document. 

1) capturing phase - event is passing through every elemnt from document to el. 
2) target phase - event arrives to destination el and event is being handled (event hanlder runs callback func).
3) bubbling phase - event travels back from el to document (thorugh every parent element up to the top of the DOM tree)

Why it's important? In bubbling phase if parent elements also handle the same type of events (have event listerens) then those events can be handled also by parent elements. 
One in target element and second e.g in section element.

e.target // where the event happend orginally 
e.currentTarget // 'this' - caller of the callback function

Bubbling can be disabled:
e.stopPropagation(); // generally not a good idea to use it

.addEventListener('click', function(e){}, true); // event listener will be listening to capture events instead of bubbling events (false by default)


Event delegation:

Using common parent element to handle children events from bubbling up. Better performance than looping over all elements (e.g multiple buttons).
Useful when elements are added dynamically to the page (not exisitiing in runtime yet)

Page Navigation

Not very efficient solution - poor performance :

navLinks.forEach(function(btn) {btn.addEventListener('click', function(e) {
  e.preventDefault();
  const href = this.getAttribute('href');
  document.querySelector(href).scrollIntoView({behavior:'smooth'});
})});

better solution = Event Delegation :
1. Add event listener to common parent element
2. Deterimne what element originated the event

document.querySelector('.nav__links').addEventListener('click', function(e) {
  e.preventDefault();
  if (e.target.classList.contains('nav__link')) {
    const href = e.target.getAttribute('href');
    document.querySelector(href).scrollIntoView( {behavior: 'smooth'});
  }
});

// 5. DOM Traversing

Walking thorugh the DOM - selecting an element based on another element. Selecting direct child or parant etc.

Going downwards - children:
h1.querySelectorAll('.highlight');
h1.childNodes; // text, comment, text, span.highlight...
h1.children; // html collection with elements
h1.firstElementChild.style.color = 'white';

Going upwards - parents:
h1.parentNode;
h1.parentElement;
h1.closest('.header'); // query selector of closest parent element, normal query selector finds children
h1.closest(h1); // h1 itself

Going sideways - siblings:

h1.previousElementSibling;
h1.nextElementSibling;

h1.previousSibling; // node, not element
h1.nextSibling; // node, not element

h1.parentElement.children; // all siblings and element itself

// 6. Passing arguments to event handlers

bind() - returns new function, can add additional arguments - changes 'this'

mouseenter doesn't bubble
mouseover bubbles

const handleHover = function(e) {
    //console.log(this, e.currentTarget);
  
    if (e.target.classList.contains('nav__link')) {
      const link = e.target;
      const siblings = link.closest('.nav').querySelectorAll('.nav__link');
      const logo = link.closest('.nav').querySelector('img');
  
      siblings.forEach(el =>  { if (el !== link) el.style.opacity = this; });
      logo.style.opacity = this;
    }
  };
  
  // nav.addEventListener('mouseover', function(e) {
  //   handleHover(e, 0.5);
  // });
  // nav.addEventListener('mouseout', function(e) {
  //   handleHover(e, 1);
  // });
  
  nav.addEventListener('mouseover', handleHover.bind(0.5));
  nav.addEventListener('mouseout', handleHover.bind(1));

// 7. Lifecycle DOM events

DOM content loaded => event fired when html complately parsed, all scripts downloaded and executed are loaded before this event
Don't put script tag in HEAD. Put script tag in html document on the bottom so you dont have to wait for DOMContentLoaded event. Applies to old browsers.
document.readyState property ?

document.addEventListener('DOMContentLoaded', function (e) {
  console.log('HTML parsed and DOM tree built');
});

// page fully loaded event
window.addEventListener('load', function(e) {
  console.log('Page fully loaded event');
});

// leave site popup
window.addEventListener('beforeunload', function(e) {
  e.preventDefault();
  console.log('Page closing event');
  e.returnValue = '';
});

// 8. Efficient script loading defer and async

Only modern browsers support async and defer. Everything depends on use case.
Overall the best solution when execution order matters (including libraries?) is defer in HEAD. It will parse HTML and fetch scripts asynchronously and once ready execute script

<img src="http://127.0.0.1:5500/Udemy%20course/img/AdvancedDOM_EfficientScriptLoading.JPG" height="80%" width="80%"/>






-----------------------------------------------------------------------------------------
` + "</code></pre>";


//Practice:

console.log('test')

document.addEventListener('DOMContentLoaded', function (e) {
  console.log('HTML parsed and DOM tree built');
});


// leave site popup
// window.addEventListener('beforeunload', function(e) {
//   e.preventDefault();
//   console.log('Page closing event');
//   e.returnValue = '';
// });